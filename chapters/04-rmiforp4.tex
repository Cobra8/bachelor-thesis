% !TEX root = ../main.tex

\chapter{RMI for P4}
\label{ch:rmiforp4}

\section{RMI reference implementation}
The RMI reference implmentation following from \cite{cdfshop} available at \cite{rmi-reference} is implemented in Rust and primarily serves as a compiler that takes in a dataset as input and outputs C++ source code files. In this constellation one can play with multiple tuning parameters in order to influence the generated code and with that the potential performance of the generated implementation. Concretely there is the possibility to choose which model type is used on which level as well as a parameter called the branching factor that determines the number of leaf models between two layers. The reference implementation currently supports nine different types of model types the most frequently used ones being linear and cubic. The functionality of the implemenntation though does not stop at this point, instead there is a possibility to pass an optimize optio to the executable to let RMI perform automatic tuning that outputs a table that covers heuristically selected possible RMI configurations that cover the Pareto front. This table then contains different suggestion for which combination of models can be used together with a suggested branching factor as well as information about the layer parameters size and approximately how many binary search steps will be needed in the last mile search. This table can fruther be used as input to the reference implementation to directly generate code for each table entry.

\section{Adaptation for P4}
Until now the the in chapter \ref{ch:rmionbmv2} discussed RMI implementation for BMv2 was extremely unflexible and solely focussed on a single dataset where every configuration or adaptation step was done by hand in a quite uncomfortable way. This chapter is about going a step further, where an adaptation of the reference RMI implementation in Rust should potentially be able to automatically generate P4 source code files depending on which input dataset was used and what models were selected. With this not only an RMI implementation in P4 for the books\_200M dataset with 32-bit keys should be doable but instead lots of different configurations for all provided SOSD datasets hopefully become runnable on the BMv2 switch.\\

An important thing to mention though is that the entire mathematical or learned part of the reference RMI implementation will stay completely untouched and mainly the code generation part of the project will be adjusted and extended.

\section{Code generation}
Generally when looking at the fully implemented final result from chapter \ref{ch:rmionbmv2} a lot of static code is to be found in the P4 file that can be used for any sort of dataset or model combination. Coyping all these header definitions or the normalization function and other helper functions into a P4 source file is straight forward. A first thing that remains is to treat code generation for different models lookup functions depending on which models are used. An important property here is that a function should really only be printed into the result file if it is actually needed. This is covered in more detail in section \ref{sect:rmiforp4:linear_cubic} and \ref{sect:rmiforp4:radix}. Until here still not much complexity is involved. A next thing to treat is code generation of the actual lookup function which has to adapt with respect to different model combinations. This is more or less the centerpiece and most complex part of the code generation and discussed more in detail in \ref{sect:rmiforp4:lookup}. Finally the code generation that makes sure that model parameters can be sent over to the switch via P4Runtime in Python or when small enough statically printed into the result source file is left. This part of the implementation proved to be more complex than initially thought since the generated Pyhton source file for P4Runtime has to seamlessly work with the P4 table definition printed into the P4 source file. This is looked at in more detail in \ref{sect:rmiforp4:parameters}.

\subsection{For linear and cubic models}
\label{sect:rmiforp4:linear_cubic}
The inner workings of the lookup functions for both of these models were already quite extensively covered in section \ref{sect:rmionbmv2:implmentation} and \ref{sect:rmionbmv2:fma} together with the concrete implementation shown in the appendix in section \ref{sect:appendix:fma}. The only thing left for the code generation in the rust implementation apart from printing said code into the P4 source file is to make sure that either static model parameters are correctly printed into the source file or that larger amounts of model parameters are correctly loaded during the switches runtime. As already stated this is looked at in a more general approach in section \ref{sect:rmiforp4:parameters}.

\subsection{For radix models}
\label{sect:rmiforp4:radix}
The lookup function for radix models fortunately is the only lookup function that does not rely on floating point arithmetic and is therefore predestined to work in P4. The reference RMI implementation contains two radix models. The first of them uses a certain prefix length to bit shift on the input to generate a radix value which is directly the resulting output of the model whereas the second model does calculate a radix value based on the input the same way but instead uses it then to index a radix table which then serves as the resulting output of the model. For these models the adaptation into P4 and code generation is even simpler since all necessary primitive operations used are also available in P4. The second radix model involving a radix table though needs a bit more consideration which involves loading the radix table using the mechanisms described in \ref{sect:rmiforp4:parameters} and adapting the lookup function generation accordingly.

\subsection{For the lookup function}
\label{sect:rmiforp4:lookup}
The lookup function is probably the most important but with that also the trickiest part of the code generation implementation. In this part all sorts of combinations of models as well as other properties of the learned RMI must be considered. Generally due to the nature of RMI in the sense that each model layer's output provides the input index for the next layer, the generation code works in the same way by looping over each generated layer. For each layer based on model properties it is decided if floating point or integer input and output is needed. Based on this information, conversions between layers are added if necessary. Further there is a difference between code generation for the first layer and all following layers. Theoretically several following model layers are possible but the reference implementation and especially in the scope of this work, as previously stated, focus lies on only one single following layer from now on designated as second layer. With that said when generating code for the first layer, the model parameters originally printed into a header file are now converted to the customly defined floating point header format in P4 and statically written into the resulting source code file as input for the model function. One exception to this being the model involving a radix table where additionally to the call of the model function a table lookup happens into the model parameters table loaded with the mechanism described in the next section to make the sure the correct output index is retrieved as input for the next layer. Even though this is already implied, in both cases the code generation does insert a call to the respective model function at the appropriate location. Finally when generating code for a following second layer model, first a call to the function that looks into the model parameters table to retrieve the corresponding model parameters gets written to the source code file with the index from the previous layer as input index. Finally a call to the second layer model function is appended with the just retrieved model parameters as input arguments. At the end a function to calculate the final result by clamping it to a value between 0 and the dataset size is appended and with that the generation of the lookup function is complete.

\subsection{For loading model parameters}
\label{sect:rmiforp4:parameters}



\section{Supporting other models}
% TODO: maybe write / discard this chapter?
% explain why some of the other models are hard to implement in P4 but potentially doable
% time is short and the fact that this is a proof of concept
% not really having the goal of production-grade software (would have to respect all the linitations discussed in chapter \ref{evalutation chapter})
% also when looking at optimization tables generated for mostly all SOSD datasets linear and cubic are clearly the most important and most often used models
