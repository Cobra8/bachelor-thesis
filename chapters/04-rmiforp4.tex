% !TEX root = ../main.tex

\chapter{RMI for P4}
\label{ch:rmiforp4}

\section{RMI reference implementation}
The RMI reference implmentation following from \cite{cdfshop} available at \cite{rmi-reference} is implemented in Rust and primarily serves as a compiler that takes in a dataset as input and outputs C++ source code files. In this constellation one can play with multiple tuning parameters in order to influence the generated code and with that the potential performance of the generated implementation. Concretely there is the possibility to choose which model type is used on which level as well as a parameter called the branching factor that determines the number of leaf models between two layers. The reference implementation currently supports nine different types of model types the most frequently used ones being linear and cubic. The functionality of the implemenntation though does not stop at this point, instead there is a possibility to pass an optimize optio to the executable to let RMI perform automatic tuning that outputs a table that covers heuristically selected possible RMI configurations that cover the Pareto front. This table then contains different suggestion for which combination of models can be used together with a suggested branching factor as well as information about the layer parameters size and approximately how many binary search steps will be needed in the last mile search. This table can fruther be used as input to the reference implementation to directly generate code for each table entry.

\section{Adaptation for P4}
Until now the in chapter \ref{ch:rmionbmv2} discussed RMI implementation for BMv2 was extremely unflexible and solely focussed on a single dataset where every configuration or change was done by hand in a quite uncomfortable way. This chapter is about going a step further, where an adaptation of the reference RMI implementation in Rust should potentially be able to automatically generate P4 source code files depending on which input dataset was used and what models were selected. With this not only an RMI implementation in P4 for the books\_200M dataset with 32-bit keys should be doable but instead lots of different configurations for all provided SOSD datasets hopefully become runnable on the BMv2 switch.\\

An important thing to mention though is that the entire mathematical or learned part of the reference RMI implementation will stay completely untouched and only the code generation part of the reference implementation will be adjusted.

\section{Code generation}
Generally when looking at the fully implemented final result from chapter \ref{ch:rmionbmv2} a lot of static code is to be found in the P4 file that can be used for any sort of dataset or model combination. Coyping all these header definitions or the normalization function and other helper functions into a P4 source file is straight forward. A first thing that remains is to treat code generation for different mathematical helper functions depending on which models are used. An important property here is that a function should really only be printed into the result file if it is actually needed. This is covered in more detail in sections \ref{sect:rmiforp4:linear_cubic} and \ref{sect:rmiforp4:radix}. Until here still not much complexity is involved. A next thing to treat is code generation of the actual lookup function which has to adapt with respect to different model combinations. This is more or less the centerpiece and most complex part of the code generation and discussed more in detail in section \ref{sect:rmiforp4:lookup}. Finally the code generation that makes sure that model parameters can be sent over to the switch via P4Runtime in Python or when small enough statically printed into the result source file remains. This part of the implementation proved to be more complex than initially thought since the generated Pyhton source file for P4Runtime has to seamlessly work with the table declaration printed into the P4 source file. This is looked at in more detail in section \ref{sect:rmiforp4:parameters}.

\subsection{For linear and cubic models}
\label{sect:rmiforp4:linear_cubic}
The inner workings of the lookup functions for both of these models were already quite extensively covered in section \ref{sect:rmionbmv2:implmentation} and \ref{sect:rmionbmv2:fma} together with the concrete implementation shown in the appendix in section \ref{sect:appendix:fma}. The only thing left for the code generation in the proposed implementation apart from printing said code into the P4 source file is to make sure that either static model parameters are correctly printed into the source file or that larger amounts of model parameters are correctly loaded during the switches runtime. As already stated this is looked at from a more general point of view in section \ref{sect:rmiforp4:parameters}.

\subsection{For radix models}
\label{sect:rmiforp4:radix}
For radix models the model function is fortunately the only one that does not rely on floating point arithmetic and is therefore predestined to work in P4. The reference RMI implementation contains two radix models. The first of them uses a certain prefix length to bit shift on the input to generate a radix value which is directly the resulting output of the model whereas the second model does calculate a radix value based on the input the same way but instead uses it then to index a radix table which then serves as the resulting output of the model. For these models the adaptation into P4 and code generation is even simpler since all necessary primitive operations used are also available in P4. The second radix model involving a radix table though needs a bit more consideration which involves loading the radix table using the mechanisms described in \ref{sect:rmiforp4:parameters} and adapting the lookup function generation accordingly.

\subsection{For the lookup function}
\label{sect:rmiforp4:lookup}
The lookup function is probably the most important but with that also the trickiest part of the code generation implementation. In this part all sorts of combinations of models as well as other properties of the learned RMI must be considered. Generally due to the nature of RMI in the sense that each model layer's output provides the input index for the next layer, the generation code works in the same way by looping over each generated layer. For each layer based on model properties it is decided if floating point or integer input and output is needed. Based on this information, conversions between layers are added if necessary. Further there is a difference between code generation for the first layer and all following layers. Theoretically several following model layers are possible but the reference implementation and especially in the scope of this work, as previously stated, focus lies on only one single following layer from now on designated as second layer. With that said when generating code for the first layer, the model parameters originally printed into a header file are now converted to the customly defined floating point header format in P4 and statically written into the resulting source code file as input for the model function. One exception to this being the model involving a radix table where additionally to the call of the model function a table lookup happens into the model parameters table loaded with the mechanism described in the next section to make the sure the correct output index is retrieved as input for the next layer. Even though this is already implied, in both cases the code generation does insert a call to the respective model function at the appropriate location. Finally when generating code for a following second layer model, first a call to the function that looks into the model parameters table to retrieve the corresponding model parameters gets written to the source code file with the index from the previous layer as input index. Finally a call to the second layer model function is appended with the just retrieved model parameters as input arguments. At the end a function to calculate the final result by clamping it to a value between 0 and the dataset size is appended. With that the generation of the lookup function is complete.

\subsection{For loading model parameters}
\label{sect:rmiforp4:parameters}
In order to load model parameters for each layer multiple steps need to be taken meaning that multiple source code files are concerned. Generally the RMI reference implementation does already dump larger chunks of layer parameters into a simple binary file. The idea of saving a binary file containing all layer parameters for later use is kept by the proposed implementation. With that said two code areas need to be covered. The first one being the table declaration itself in the P4 source code file. A table declaration and a corresponding table lookup function are added to the P4 source file whenever a layer needs to load model parameters. The generation of this function takes into account how many parameters need to be loaded and how large the table is going to be based on the learned RMI layer properties. Finally the generated table lookup function can be used at the appropriate position in the lookup function in order to retrieve layer parmeters for a specific model index. The second area that has to be generated differs from the just explained since being implemented in Python. The reason being that since not having any possibility of loading files during runtime on the switch there is no way of dynamically loading model parameters in P4. The solution that is proposed by \cite{p4runtime-spec} is to use P4Runtime. In this regard the second part of the code generation has to generate a Python source code file that loads the previously stored layer parameters from said binary file and that uses the P4Runtime environement to fill the previously defined table from the control plane. It does so by creating table entries for each model parameter loaded from the binary file and writing these entries in batches to the switch.

\section{How to run the generated code}
All together this creates a process where based on a learned RMI configuration the proposed implementation in this chapter can output a P4 and a Python source code file. The idea is to first setup the virtual network via Mininet that contains a least one switch which is executing the freshly generated P4 source code file. When everything is operating correctly the generated P4Runtime python file can be run in order to load model parameters from the saved binary file and send them to the switch. Finally after this process is complete the switch is able to successfully respond to incoming learned RMI packets formatted as described in the previous chapter in section \ref{sect:rmionbmv2:network}.

\section{Supporting other models}
Currently the proposed adaptationn does only supprt the three model types described in sections \ref{sect:rmiforp4:linear_cubic} and \ref{sect:rmiforp4:radix}. The reference implementation on the other hand does support additional model types like normal, logarithmic or histogram models. There are multuple reasons coming all together for why these models are currently not supported.\\

A first reason and probably the most important one being that these models are hard to implement in P4 because they all rely on some additional mathematical function which in turn relies on some currently not implemented floating point arithmetic function. One such example being the exp function that is used for the normal or logarithmic model types. In my opinion there is no reason why for this function a similar approach than the one taken for the FMA instruction would not work. In other words a software implementation of said mathematical floating point arithmetic functions would probably be doable in P4. Currently though since time is short and since this project does not necessarily have the goal of being a full copy of the reference implementation these model types are left for further work. Lastly also quite a major reason coming from a more practically oriented point of view, when looking at all pareto optimal configurations generated by the reference RMI implementation, most of them rely on some combination of linear and cubic model types.
