% !TEX root = ../main.tex

\chapter{Conclusion}
\label{ch:conclusion}
In this work we started by evaluating different learned index structures by their potential programmability in P4. We compared performances of different (learned) index structures using the SOSD benchmark \cite{sosd-neurips} and looked at what is possible as well as what the limits of network programmability are. We came to the conclusion that the RMI learned index structure initially proposed in \cite{rmi} is a good fit for further pursuing our idea of implementing a learned index structure in P4 in order to run lookup calculations on the fly over the network.\\

In a next step we implemented a proof of concept by hand in P4 testing it's operability on virtually simulated hardware and found that an RMI implementation with perfect accuracy in P4 is indeed possible. At the same time though, we learned what limitations apply on real world switch hardware that do not exist in simulated hardware which proved to be crucial for our implementation. This leads to probably the most pertinent conclusion of this work, namely that in order for learned indices to become viable solutions in real world applications in the future, switches need to be able to support floating point arithmetic ideally on their ALUs or even FPUs or in some other computationally cheap form. In the same sense another limitation which we are facing, especially strengthened due to the fact that we na√Øvly implemented floating point arithmetic directly in P4, is that real world switches are limited by the amount of CPU stages, meaning that chained operation complexity for a single packet is pretty quickly exploited.\\

Since now having implemented a proof of concept by hand that worked for a specific dataset and a specific RMI configuration we opted for a more generalizable approach, by adapting the RMI reference implementation \cite{cdfshop} in a way that P4 source code files can be generated for any input dataset and mostly any arbitrary RMI configuration.\\

Finally in a last step we tried to circumvent the fact that our implementation is theoretical and tried, based on what we have, to theoretically estimate, how much an RMI implementation over the network could save in a closed system. We come to the conclusion that when assuming ideal circumstances, where an RMI implementation in P4 exists under which a switch can operate at state-of-the-art packet processing rates in an application where a lookup has to be sent over the network anyways, then our idea could potentially leverage each last mile search worker by a constant magnitude of around 50-100ns per lookup depending on the dataset and RMI configuration.

\section{Future Work}
The continuation of this work would initially consist of finding solutions for the different limitations and assumptions that were taken in the scope of this work in order to arrive at a real world learned index structure implementation over the network. One solution for floating point arithmetic could come for instance, from an immensely interesting paper \cite{netfc} about enabling accurate floating point arithmetic on P4 capable switches in a smarter way than we did for this work. Unfortunately, the results are currently limited to 16-bit floating point arithmetic and everything beyond is left as future work. Enabling wider floating point arithmetic on P4 capable switches thus would be a great starting point for our future work, especially if switches's capabilities augment in the future. Further there is another paper \cite{maltry2021critical} which proposes an alternative implementation for finding RMI configurations that yield similar lookup times and often better build times. The result of this alternative implementation could be used as input to the P4 code generation part of our adaptation of the reference implementation. This does not immediately lead to a solution of one of the problems shown in this work could further leverage the power of RMI. Finally when looking at all limitations and assumptions that we discovered during this work, most of them could either bes solved or at least greatly weakened when having hardware supported floating point arithmetic. In that sense a very systems related but extremly interesting start for our future work could be to try to extend the capabilities of network switches or potentially NICs to support floating point arithmetic.

When taking a step back, reevaluating other or in the future also new learned index structures regarding their network programmability will continuously be a good starting point for our future work.
